# Buntspecht Development Guide

## Project Overview

**Buntspecht** is a TypeScript-based multi-platform social media bot that automatically posts messages to **Mastodon**, **Bluesky**, and other platforms. It supports various message sources, middleware processing, webhook integrations, and comprehensive observability features.

### Key Features
- 🌐 Multi-platform support (Mastodon, Bluesky)
- 🤖 Multiple message providers (ping, command, JSON, RSS, push)
- 🔧 Powerful middleware system for message transformation
- 🔐 External secret management (Vault, AWS, Azure, GCP)
- 📊 OpenTelemetry observability
- ⚡ Bun runtime with single binary compilation
- 🐳 Docker support for production deployment

## Architecture

### Core Components

1. **Message Providers** (`src/messages/`)
   - `PingProvider` - Static messages
   - `CommandProvider` - External command execution
   - `JsonCommandProvider` - JSON template processing
   - `MultiJsonCommandProvider` - Advanced JSON processing with caching
   - `PushProvider` - Webhook-triggered messages
   - `RSSFeedProvider` - RSS feed monitoring

   **MultiJson Architecture** (`src/messages/multiJson/`):
   - `CacheMigrator` - Handles cache format migrations between versions
   - `ExecutionScheduler` - Command execution and timing management
   - `MessageDeduplicator` - Prevents duplicate message posting via cache
   - `MessageGenerator` - Core message generation logic
   - `JsonArrayProcessor` - Processes JSON arrays with filtering
   - `TemplateProcessor` - Template processing for JSON data

2. **Social Media Clients** (`src/services/`)
   - `MastodonClient` - Mastodon API integration
   - `BlueskyClient` - Bluesky/AT Protocol integration
   - `SocialMediaClient` - Unified client interface

3. **Middleware System** (`src/services/middleware/`)
   - 9 built-in middleware types for message processing
   - Provider-specific middleware isolation
   - Chainable transformations and filters

4. **Scheduling & Execution** (`src/services/scheduler/`)
   - `MultiProviderScheduler` - Main orchestrator
   - `ProviderManager` - Provider lifecycle management
   - `ExecutionEngine` - Task execution with strategies

5. **Secret Management** (`src/services/secrets/`)
   - Multiple secret providers (Vault, AWS, Azure, GCP, File, Env)
   - Automatic secret rotation detection
   - Secure credential handling

6. **Webhook Server** (`src/services/webhook/`)
   - HTTP webhook endpoint for push notifications
   - Rate limiting and validation
   - Template-based message processing

## Development Guidelines

### Code Organization

- **Single Responsibility**: Each class/module has a clear, focused purpose
- **Strategy Pattern**: Used for provider execution and secret handling
- **Factory Pattern**: Used for creating providers and middleware
- **Dependency Injection**: Services receive dependencies via constructor
- **Interface Segregation**: Clear interfaces for different concerns

### File Structure Conventions

```
src/
├── messages/           # Message providers
├── services/          # Core services
│   ├── execution/     # Provider execution strategies
│   ├── middleware/    # Message middleware system
│   ├── scheduler/     # Scheduling and orchestration
│   ├── secrets/       # Secret management
│   └── webhook/       # Webhook handling
├── types/             # TypeScript interfaces
├── utils/             # Utility functions
└── __tests__/         # Test files (mirror src structure)
```

### Testing Standards

- **Comprehensive Coverage**: 400+ tests across the codebase
- **Test Utilities**: Shared helpers in `src/__tests__/utils/`
- **Mock Factories**: Standardized mocks for consistent testing
- **Integration Tests**: Full workflow testing for critical paths
### Test Commands**:
  ```bash
  bun run test           # Run all tests (Jest via Bun - PRIMARY)
  bun run test:coverage  # Run with coverage report
  bun run test:watch     # Watch mode for development
  
  # Individual test files can also be run with Bun directly:
  bun test src/__tests__/specific-file.test.ts  # Bun native test runner
  ```

### Test Migration Status

**Current State**: We are migrating from Jest/Node.js to Bun's native test runner.

- **Primary Test Suite**: Uses Jest via `bun run test` (Bun running Jest)
- **New Test Files**: Should be compatible with both Jest and Bun test runners
- **Individual Testing**: New tests can be run with `bun test filename.test.ts` for faster iteration
- **CI/CD**: Still uses the Jest test suite for comprehensive validation

**Migration Guidelines**:
- Write tests that work with both Jest and Bun test runners
- Use standard test syntax (describe, it, expect) that both support
- Avoid Jest-specific features in new tests when possible
- Test new files with both runners to ensure compatibility

**Future Goal**: Make `bun test` work for the entire test suite by:
- Removing Jest-specific test methods (e.g., `jest.mock`, `jest.fn`)
- Eliminating Node.js-only features that Bun doesn't support
- Converting to Bun-compatible mocking and testing patterns
- Ensuring all tests can run with `bun test` natively without Jest dependency

### Code Quality

- **TypeScript**: Strict type checking enabled
- **ESLint**: Comprehensive linting rules
- **Error Handling**: Graceful error handling with telemetry
- **Logging**: Structured logging with configurable levels
- **Documentation**: JSDoc comments for public APIs

## Development Workflow

### Local Development

```bash
# Install dependencies
bun install

# Run in development mode
bun run dev

# Build TypeScript
bun run build

# Run tests
bun run test

# Lint code
bun run lint
```

### Configuration

- **TOML Format**: All configuration in TOML files
- **Secret Sources**: Support for external secret providers
- **Environment Variables**: Override configuration via env vars
- **Validation**: Comprehensive config validation on startup

### Release Process

1. **Version Management**: Update `package.json` and `src/version.ts`
2. **Quality Checks**: Run tests, linting, and coverage
3. **Binary Building**: Multi-platform binary compilation
4. **Automated Release**: GitHub Actions handles releases
5. **Docker Images**: Automatic container builds

### Binary Compilation

- **Bun Compilation**: Single binaries for all platforms
- **OpenTelemetry Exclusion**: Telemetry deps excluded from binaries
- **Platform Support**: Linux (x64, ARM64), macOS (Intel, Apple Silicon)

## Key Patterns & Best Practices

### Message Processing

1. **Provider Isolation**: Each provider runs independently
2. **Middleware Chains**: Transform messages before posting
3. **Error Isolation**: Provider failures don't affect others
4. **Telemetry Integration**: Comprehensive observability
5. **Null/Undefined Handling**: Template functions (like `join`) gracefully handle missing data

#### Template Function Enhancements

The `join` function in templates now handles edge cases:
- `{{tags|join: ,#}}` with `undefined` tags → expands to empty string
- `{{tags|join: ,#}}` with `null` tags → expands to empty string  
- `{{tags|join: ,#}}` with `[]` tags → expands to empty string
- `{{tags|join: ,#}}` with `["tag1", "tag2"]` → expands to `#tag1 #tag2`

This prevents template placeholders from appearing in final messages when data is missing.

### Secret Management

1. **External Sources**: Never store secrets in config files
2. **Rotation Detection**: Automatic credential updates
3. **Secure Handling**: Secrets never logged or exposed
4. **Multiple Providers**: Support for various secret backends

### Error Handling

1. **Graceful Degradation**: Continue operation on non-critical failures
2. **Retry Logic**: Configurable retry mechanisms
3. **Telemetry**: Error tracking and metrics
4. **User Feedback**: Clear error messages and logging

### Performance

1. **Async Operations**: Non-blocking I/O throughout
2. **Caching**: Intelligent caching for expensive operations
3. **Resource Management**: Proper cleanup and resource disposal
4. **Rate Limiting**: Built-in rate limiting for external APIs

## Testing Guidelines

### Test Structure

- **Unit Tests**: Test individual components in isolation
- **Integration Tests**: Test component interactions
- **Mock Usage**: Use provided mock factories for consistency
- **Test Helpers**: Leverage shared utilities for setup

### Test Naming

```typescript
describe('ComponentName', () => {
  describe('methodName', () => {
    it('should do something when condition', () => {
      // Test implementation
    });
  });
});
```

### Mock Patterns

```typescript
import { createMockLogger, createMockTelemetry } from '../utils/testHelpers';

// Use standardized mocks
const mockLogger = createMockLogger();
const mockTelemetry = createMockTelemetry();
```

## Middleware Development

### Built-in Middleware Types

1. `text_transform` - Text transformations
2. `filter` - Content filtering
3. `command` - External command execution
4. `template` - Template processing
5. `conditional` - Conditional logic
6. `schedule` - Time-based filtering
7. `rate_limit` - Rate limiting
8. `attachment` - File attachment handling
9. `openrouter` - AI-powered enhancements
10. `youtube_caption` - YouTube video caption extraction and processing
11. `youtube_premiere_filter` - Filter out YouTube premiere videos
12. `youtube_shorts_filter` - Filter out YouTube Shorts videos
13. `youtube_video_filter` - General YouTube video filtering

### Custom Middleware

Implement the `MessageMiddleware` interface:

```typescript
export class CustomMiddleware implements MessageMiddleware {
  readonly name: string;
  readonly enabled: boolean;

  async execute(context: MessageMiddlewareContext, next: () => Promise<void>): Promise<void> {
    // Transform context.message
    // Set context.skip = true to skip posting
    await next(); // Continue chain
  }
}
```

## Deployment

### Docker (Recommended)

```bash
# Pull latest image
docker pull ghcr.io/rmoriz/buntspecht:latest

# Run with configuration
docker run -d \
  --name buntspecht \
  -v /path/to/config.toml:/app/config.toml:ro \
  -p 3000:3000 \
  ghcr.io/rmoriz/buntspecht:latest
```

### Binary Deployment

```bash
# Download platform-specific binary
wget https://github.com/rmoriz/buntspecht/releases/latest/download/buntspecht-linux-x64
chmod +x buntspecht-linux-x64
./buntspecht-linux-x64 --help
```

## Troubleshooting

### Common Issues

1. **OpenTelemetry**: Only works with Docker or `bun run`, not binaries
2. **Secret Resolution**: Check external secret provider connectivity
3. **Rate Limiting**: Monitor API rate limits for social platforms
4. **Memory Usage**: Monitor for memory leaks in long-running instances

### Debug Mode

```toml
[logging]
level = "debug"
```

### CLI Diagnostics

```bash
# Check provider status
buntspecht --list-providers

# Test specific provider
buntspecht --test-provider provider-name

# Verify configuration
buntspecht --verify
```

## Contributing

### Development Workflow

**MANDATORY Commit/Push Process** (MUST follow this exact order):

1. **Run Specific Tests**: Test the area you're working on
   ```bash
   bun test src/__tests__/specific-file.test.ts
   ```

2. **Run All Tests**: Ensure nothing is broken
   ```bash
   bun run test
   ```
   Note: This runs the primary Jest test suite via Bun

3. **Run Linting**: Check code quality
   ```bash
   bun run lint
   ```

4. **Fix ALL Issues**: **MUST** achieve 0 failures and 0 errors
   - Fix any test failures
   - Fix any linting errors (warnings are acceptable, but errors are NOT)
   - Re-run tests and lint until everything passes

5. **Commit Changes**: Use conventional commit format
   ```bash
   git add -A
   git commit -m "type: description"
   ```

6. **Push to Repository**:
   ```bash
   git push
   ```

**⚠️ CRITICAL**: Never commit or push with failing tests or linting errors. The build pipeline expects clean code.

### General Contributing Guidelines

1. **Fork & Branch**: Create feature branches from main
2. **Test Coverage**: Maintain or improve test coverage
3. **Documentation**: Update docs for new features
4. **Code Style**: Follow existing patterns and linting rules
5. **Commit Messages**: Use conventional commit format

### Documentation Requirements

**MANDATORY README Management** (MUST follow):

- **Primary README**: `README.md` (English) is the authoritative source
- **German README**: `README.de.md` MUST be kept synchronized with English version
- **Translation Script**: Use `scripts/update-german-readme.js` to check translation status
- **CI Validation**: GitHub Actions automatically checks README synchronization

**README Update Workflow**:
1. **Update English README**: Make changes to `README.md` first
2. **Check Translation Status**: Run `node scripts/update-german-readme.js`
3. **Update German README**: Manually update `README.de.md` to match English changes
4. **Verify Synchronization**: Re-run the script to ensure both are in sync
5. **Commit Both Files**: Always commit both README files together

**⚠️ CRITICAL**: Never commit changes to `README.md` without updating `README.de.md`. The CI pipeline will fail if the German README is out of sync.

## Security Considerations

- **Secret Management**: Use external secret providers
- **Input Validation**: Validate all external inputs
- **Rate Limiting**: Implement appropriate rate limits
- **Error Handling**: Don't expose sensitive information in errors
- **Dependencies**: Keep dependencies updated for security

---

**Note**: This is a production-ready application with comprehensive testing, observability, and deployment options. The architecture supports both simple use cases and complex enterprise deployments.